#!/usr/bin/env bash
set -euo pipefail

VERSION="0.1.0"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m'

log()  { echo -e "${GREEN}==> ${NC}$*"; }
warn() { echo -e "${YELLOW}==> ${NC}$*"; }
err()  { echo -e "${RED}==> ${NC}$*" >&2; }
info() { echo -e "${BLUE}==> ${NC}$*"; }

usage() {
  cat <<EOF
dev $VERSION — project launcher & worktree manager (powered by mise)

Usage: dev <command> [args]

Project Commands (delegated to mise tasks):
  init            Initialise a new project (generates mise.toml)
  up              Start services, install deps, setup DB, launch server
  down            Stop services
  setup           Install deps and setup DB without starting server

Worktree Commands:
  wt create NAME  Create a worktree with full setup
  wt remove NAME  Remove a worktree and its database
  wt list         List all worktrees and their status

Other:
  info            Show project info (mise config, tools, env)
  -h, --help      Show this help
  -v, --version   Show version

Configuration:
  Each project defines a mise.toml with [tools], [env], and [tasks].
  Worktree-specific overrides go in mise.local.toml (auto-generated).
EOF
}

# Find the main worktree root (first entry from git worktree list)
find_main_root() {
  git worktree list 2>/dev/null | awk 'NR==1{print $1}'
}

# Find project root (git root or current dir)
find_project_root() {
  git rev-parse --show-toplevel 2>/dev/null || pwd
}

# Detect if we're inside a worktree
is_worktree() {
  local git_dir
  git_dir=$(git rev-parse --git-dir 2>/dev/null) || return 1
  [[ "$git_dir" == *"/worktrees/"* ]]
}

# Get worktree name from current directory
worktree_name() {
  basename "$(git rev-parse --show-toplevel 2>/dev/null)"
}

# Load project env vars from mise and export PGPASSWORD for psql
load_mise_env() {
  eval "$(mise env 2>/dev/null)" || true
  export PGPASSWORD="${DB_PASSWORD:-postgres}"
}

# Check if a PostgreSQL database exists
_db_exists() {
  local db="$1"
  local host="${DB_HOST:-localhost}"
  local port="${DB_PORT:-5432}"
  local user="${DB_USER:-postgres}"
  PGPASSWORD="${DB_PASSWORD:-postgres}" psql -U "$user" -h "$host" -p "$port" -tAc \
    "SELECT 1 FROM pg_database WHERE datname='$db'" 2>/dev/null | grep -q 1
}

# Create a database from a template
_db_create_from_template() {
  local new_db="$1"
  local template="$2"
  local host="${DB_HOST:-localhost}"
  local port="${DB_PORT:-5432}"
  local user="${DB_USER:-postgres}"
  PGPASSWORD="${DB_PASSWORD:-postgres}" psql -U "$user" -h "$host" -p "$port" -c \
    "CREATE DATABASE \"$new_db\" TEMPLATE \"$template\";" 2>/dev/null
}

# Drop a database
_db_drop() {
  local db="$1"
  local host="${DB_HOST:-localhost}"
  local port="${DB_PORT:-5432}"
  local user="${DB_USER:-postgres}"
  PGPASSWORD="${DB_PASSWORD:-postgres}" psql -U "$user" -h "$host" -p "$port" -c \
    "DROP DATABASE IF EXISTS \"$db\";" 2>/dev/null
}

# Apply worktree-specific overrides via mise.local.toml
# When inside a worktree, generates mise.local.toml with DB name override
apply_worktree_context() {
  is_worktree || return 0

  local local_toml
  local_toml="$(git rev-parse --show-toplevel)/mise.local.toml"

  # Skip if mise.local.toml already exists
  if [[ -f "$local_toml" ]]; then
    return 0
  fi

  local wt_name
  wt_name=$(worktree_name)

  load_mise_env

  if [[ -n "${DB_NAME:-}" ]]; then
    local wt_db="${DB_NAME}_${wt_name}"
    wt_db=$(echo "$wt_db" | sed 's/\//-/g')
    {
      echo "# Auto-generated by dev for worktree: $wt_name"
      echo "[env]"
      echo "DB_NAME = \"$wt_db\""
    } > "$local_toml"
    mise trust "$(git rev-parse --show-toplevel)" 2>/dev/null || true
    info "Worktree DB: $wt_db"
  fi
}

wt_create() {
  if [[ $# -eq 0 ]]; then
    err "Usage: dev wt create <name> [base-branch]"
    exit 1
  fi

  local name="$1"
  local base_branch="${2:-$(git symbolic-ref --short HEAD 2>/dev/null || echo main)}"

  # Verify we're in a git repo
  if ! git rev-parse --git-dir >/dev/null 2>&1; then
    err "Not in a git repository"
    exit 1
  fi

  local project_root
  project_root=$(find_main_root)

  load_mise_env

  local wt_dir="${project_root}/.worktrees"
  local wt_path="${wt_dir}/${name}"

  # Check if worktree already exists
  if [[ -d "$wt_path" ]]; then
    err "Worktree already exists: $wt_path"
    echo "  To enter it:  cd $wt_path"
    echo "  To remove it: dev wt remove $name"
    exit 1
  fi

  # Create worktrees directory and ensure it's gitignored
  mkdir -p "$wt_dir"
  if ! grep -q '\.worktrees' "$project_root/.gitignore" 2>/dev/null; then
    echo '.worktrees/' >> "$project_root/.gitignore"
    info "Added .worktrees/ to .gitignore"
  fi

  # Fetch latest
  log "Fetching latest..."
  git fetch origin --prune 2>/dev/null || true

  # Check if branch exists remotely or locally
  local remote_exists local_exists
  remote_exists=$(git branch -r --list "origin/$name" | grep -q . && echo "yes" || echo "no")
  local_exists=$(git branch --list "$name" | grep -q . && echo "yes" || echo "no")

  log "Creating worktree: $name"
  if [[ "$remote_exists" == "yes" ]]; then
    info "Found remote branch origin/$name"
    git worktree add "$wt_path" "$name" 2>/dev/null || \
      git worktree add "$wt_path" -b "$name" "origin/$name"
  elif [[ "$local_exists" == "yes" ]]; then
    info "Found local branch $name"
    git worktree add "$wt_path" "$name"
  else
    info "Creating new branch from $base_branch"
    git worktree add "$wt_path" -b "$name" "$base_branch"
  fi

  # Copy dependency directories for speed
  local copy_dirs="${WT_COPY_DIRS:-}"
  if [[ -n "$copy_dirs" ]]; then
    log "Copying dependencies from main worktree..."
    for dir in $copy_dirs; do
      if [[ -d "$project_root/$dir" ]] && [[ ! -d "$wt_path/$dir" ]]; then
        info "  Copying $dir..."
        cp -R "$project_root/$dir" "$wt_path/$dir"
      fi
    done
  fi

  # Symlink configured files from main worktree
  local symlink_files="${WT_SYMLINK_FILES:-}"
  if [[ -n "$symlink_files" ]]; then
    log "Symlinking files from main worktree..."
    for file in $symlink_files; do
      if [[ -f "$project_root/$file" ]] && [[ ! -f "$wt_path/$file" ]]; then
        mkdir -p "$(dirname "$wt_path/$file")"
        ln -s "$project_root/$file" "$wt_path/$file"
        info "  Symlinked $file"
      fi
    done
  fi

  # Enter worktree
  cd "$wt_path"

  # Install/update deps via mise
  log "Installing dependencies..."
  mise run deps 2>/dev/null || true

  # Create worktree-specific database
  local wt_db_name=""
  if [[ -n "${DB_NAME:-}" ]]; then
    wt_db_name="${DB_NAME}_${name}"
    wt_db_name=$(echo "$wt_db_name" | sed 's/\//-/g')

    log "Setting up database: $wt_db_name"

    # Start Docker if needed
    mise run docker:up 2>/dev/null || true

    # Try template clone first (fast), fall back to fresh create
    if _db_exists "$DB_NAME"; then
      info "Cloning from $DB_NAME template..."
      if _db_create_from_template "$wt_db_name" "$DB_NAME"; then
        log "Database cloned successfully"
      else
        warn "Template clone failed, will use mise setup..."
      fi
    fi
  fi

  # Generate mise.local.toml with worktree DB override and trust it
  if [[ -n "$wt_db_name" ]]; then
    {
      echo "# Auto-generated by dev wt create"
      echo "[env]"
      echo "DB_NAME = \"$wt_db_name\""
    } > "$wt_path/mise.local.toml"
  fi

  # Trust all mise.toml locations in the worktree (handles nested configs like loop/web/)
  while IFS= read -r toml_file; do
    mise trust "$(dirname "$toml_file")" 2>/dev/null || true
  done < <(find "$wt_path" -name "mise.toml" -o -name "mise.local.toml" 2>/dev/null)

  # Allow direnv if .envrc exists in the worktree
  if [[ -f "$wt_path/.envrc" ]] && command -v direnv >/dev/null 2>&1; then
    direnv allow "$wt_path/.envrc" 2>/dev/null || true
  fi

  # Print summary
  echo ""
  echo -e "${BOLD}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
  echo -e "${BOLD}Worktree ready: $name${NC}"
  echo -e "${BOLD}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
  echo ""
  echo "  Path: $wt_path"
  if [[ -n "$wt_db_name" ]]; then
    echo "  DB:   $wt_db_name"
  fi
  echo ""
  echo "To start:"
  echo "  cd $wt_path && dev up"
  echo ""
  echo "To remove:"
  echo "  dev wt remove $name"
  echo ""
}

wt_remove() {
  if [[ $# -eq 0 ]]; then
    err "Usage: dev wt remove <name>"
    exit 1
  fi

  local name="$1"
  local project_root
  project_root=$(find_main_root)

  load_mise_env

  local wt_path="${project_root}/.worktrees/${name}"

  if [[ ! -d "$wt_path" ]]; then
    err "Worktree not found: $wt_path"
    echo ""
    echo "Available worktrees:"
    wt_list
    exit 1
  fi

  log "Removing worktree: $name"

  # Drop worktree database if configured
  if [[ -n "${DB_NAME:-}" ]]; then
    local wt_db_name="${DB_NAME}_${name}"
    wt_db_name=$(echo "$wt_db_name" | sed 's/\//-/g')

    # Start Docker if needed for DB operations
    mise run docker:up 2>/dev/null || true

    if _db_exists "$wt_db_name"; then
      info "Dropping database: $wt_db_name"
      _db_drop "$wt_db_name"
    fi

    # Also try dropping the test DB
    local wt_test_db="${DB_NAME/dev/test}_${name}"
    wt_test_db=$(echo "$wt_test_db" | sed 's/\//-/g')
    if _db_exists "$wt_test_db"; then
      info "Dropping test database: $wt_test_db"
      _db_drop "$wt_test_db"
    fi
  fi

  # Remove the git worktree
  log "Removing worktree directory..."
  git worktree remove "$wt_path" --force

  echo ""
  echo -e "${BOLD}Removed: $name${NC}"
}

wt_list() {
  local project_root
  project_root=$(find_main_root)

  load_mise_env

  echo ""
  echo -e "${BOLD}Worktrees for $(basename "$project_root"):${NC}"
  echo ""

  local worktrees
  worktrees=$(git worktree list 2>/dev/null)

  if [[ -z "$worktrees" ]]; then
    echo "  No worktrees found"
    return
  fi

  while IFS= read -r line; do
    local path branch
    path=$(echo "$line" | awk '{print $1}')
    branch=$(echo "$line" | grep -oE '\[.*?\]' | tr -d '[]')
    local name
    name=$(basename "$path")

    local db_info=""
    if [[ -n "${DB_NAME:-}" ]] && [[ "$path" != "$project_root" ]]; then
      db_info=" | DB: ${DB_NAME}_${name}"
    elif [[ -n "${DB_NAME:-}" ]]; then
      db_info=" | DB: $DB_NAME"
    fi

    if [[ "$path" == "$project_root" ]]; then
      echo -e "  ${GREEN}*${NC} $name ($branch)${db_info} ${GREEN}(main)${NC}"
    else
      echo "    $name ($branch)${db_info}"
    fi
  done <<< "$worktrees"

  echo ""
}

cmd_info() {
  echo ""
  echo -e "${BOLD}Project:${NC} $(basename "$(find_project_root)")"
  echo -e "${BOLD}Root:${NC}    $(find_project_root)"
  echo ""

  if is_worktree; then
    echo -e "${BOLD}Worktree:${NC} $(worktree_name)"
    echo ""
  fi

  echo -e "${BOLD}mise config:${NC}"
  mise ls 2>/dev/null || echo "  (no mise.toml found)"
  echo ""

  echo -e "${BOLD}Tasks:${NC}"
  mise tasks 2>/dev/null || echo "  (no tasks defined)"
  echo ""

  echo -e "${BOLD}Env (WT_* vars):${NC}"
  mise env 2>/dev/null | grep -E "^export WT_|^export DB_|^export PORT=" || echo "  (none)"
  echo ""
}

_prompt() {
  local prompt="$1" default="$2" result
  if [[ -n "$default" ]]; then
    read -r -p "  $prompt [$default]: " result
    echo "${result:-$default}"
  else
    read -r -p "  $prompt: " result
    echo "$result"
  fi
}

cmd_init() {
  local project_root
  project_root=$(find_project_root)
  local project_name
  project_name=$(basename "$project_root")

  if [[ -f "$project_root/mise.toml" ]]; then
    warn "mise.toml already exists. Run 'dev info' to see current config."
    exit 1
  fi

  log "Initializing dev for: $project_name"
  echo ""

  # Detect project type
  local project_type=""
  if [[ -f "$project_root/mix.exs" ]]; then
    project_type="elixir"
  elif [[ -f "$project_root/go.mod" ]]; then
    project_type="go"
  elif [[ -f "$project_root/package.json" ]]; then
    project_type="node"
  else
    err "Could not detect project type (no mix.exs, go.mod, or package.json found)"
    exit 1
  fi

  info "Detected: $project_type project"
  echo ""

  # Read versions from .tool-versions if present
  local tool_versions="$project_root/.tool-versions"

  if [[ "$project_type" == "elixir" ]]; then
    # --- Versions ---
    local elixir_default erlang_default
    elixir_default=$(grep "^elixir " "$tool_versions" 2>/dev/null | awk '{print $2}') || true
    erlang_default=$(grep "^erlang " "$tool_versions" 2>/dev/null | awk '{print $2}') || true
    [[ -z "$elixir_default" ]] && elixir_default=$(mise ls elixir 2>/dev/null | awk '{print $2}' | tail -1) || true
    [[ -z "$erlang_default" ]] && erlang_default=$(mise ls erlang 2>/dev/null | awk '{print $2}' | tail -1) || true

    local elixir_version erlang_version
    elixir_version=$(_prompt "Elixir version" "$elixir_default")
    erlang_version=$(_prompt "Erlang version" "$erlang_default")

    # --- Port ---
    local port_default
    port_default=$(grep -E "port: [0-9]+" "$project_root/config/dev.exs" 2>/dev/null | grep -oE "[0-9]{4,5}" | head -1) || true
    port_default="${port_default:-4000}"
    local port
    port=$(_prompt "PORT" "$port_default")

    # --- Database ---
    local db_name_default
    db_name_default=$(grep -E 'database:' "$project_root/config/dev.exs" 2>/dev/null | grep -oE '"[^"]+"' | tr -d '"' | head -1) || true
    local has_db=false db_name db_port
    if [[ -n "$db_name_default" ]]; then
      has_db=true
      db_name=$(_prompt "DB_NAME" "$db_name_default")
      db_port=$(_prompt "DB_PORT" "5432")
    else
      local db_answer
      db_answer=$(_prompt "Does this project use a database? (y/n)" "n")
      if [[ "$db_answer" == "y" ]]; then
        has_db=true
        db_name=$(_prompt "DB_NAME" "${project_name}_dev")
        db_port=$(_prompt "DB_PORT" "5432")
      fi
    fi

    # --- Docker ---
    local has_docker=false
    if [[ -f "$project_root/docker-compose.yml" ]] || [[ -f "$project_root/docker-compose.yaml" ]]; then
      has_docker=true
      info "Found docker-compose.yml"
    fi

    echo ""
    log "Writing mise.toml..."

    # Build the TOML
    {
      echo "[tools]"
      echo "erlang = \"$erlang_version\""
      echo "elixir = \"$elixir_version\""
      echo ""
      echo "[env]"
      echo "PORT = \"$port\""
      if [[ "$has_db" == true ]]; then
        echo "DB_NAME = \"$db_name\""
        echo "DB_PORT = \"$db_port\""
        echo "DB_USER = \"postgres\""
        echo "DB_PASSWORD = \"postgres\""
        echo "DB_HOST = \"localhost\""
      fi
      echo ""
      echo "# Worktree config"
      echo "WT_COPY_DIRS = \"deps _build\""
      echo ""

      if [[ "$has_docker" == true ]]; then
        local container_name="${project_name}_postgres"
        echo "[tasks.\"docker:up\"]"
        echo "description = \"Start Docker postgres\""
        echo "run = '''"
        echo "  if docker ps --filter \"name=$container_name\" --filter \"status=running\" | grep -q $container_name; then"
        echo "    echo \"==> Container already running\""
        echo "  else"
        echo "    docker-compose up -d"
        echo "    echo \"==> Waiting for postgres...\""
        echo "    for i in \$(seq 1 30); do"
        echo "      docker exec $container_name pg_isready -U postgres >/dev/null 2>&1 && break"
        echo "      sleep 1"
        echo "    done"
        echo "  fi"
        echo "  echo \"==> Postgres ready\""
        echo "'''"
        echo ""
        echo "[tasks.\"docker:down\"]"
        echo "description = \"Stop Docker postgres\""
        echo "run = \"docker-compose down\""
        echo ""
      fi

      echo "[tasks.deps]"
      echo "description = \"Install Elixir dependencies\""
      echo "run = \"mix deps.get\""
      echo ""

      if [[ "$has_db" == true ]]; then
        echo "[tasks.\"db:setup\"]"
        echo "description = \"Create and migrate database\""
        if [[ "$has_docker" == true ]]; then
          echo "depends = [\"docker:up\", \"deps\"]"
        else
          echo "depends = [\"deps\"]"
        fi
        echo "run = ["
        echo "  \"mix ecto.create 2>/dev/null || true\","
        echo "  \"mix ecto.migrate\""
        echo "]"
        echo ""
      fi

      echo "[tasks.up]"
      echo "description = \"Start server\""
      if [[ "$has_db" == true ]] && [[ "$has_docker" == true ]]; then
        echo "depends = [\"docker:up\", \"deps\", \"db:setup\"]"
      elif [[ "$has_db" == true ]]; then
        echo "depends = [\"deps\", \"db:setup\"]"
      else
        echo "depends = [\"deps\"]"
      fi
      echo "run = \"iex -S mix phx.server\""
      echo "raw = true"
      echo ""

      echo "[tasks.down]"
      echo "description = \"Stop services\""
      if [[ "$has_docker" == true ]]; then
        echo "run = \"docker-compose down\""
      else
        echo "run = \"echo 'nothing to stop'\""
      fi
      echo ""

      echo "[tasks.setup]"
      echo "description = \"Install deps and setup DB (no server)\""
      if [[ "$has_db" == true ]] && [[ "$has_docker" == true ]]; then
        echo "depends = [\"docker:up\", \"deps\", \"db:setup\"]"
      elif [[ "$has_db" == true ]]; then
        echo "depends = [\"deps\", \"db:setup\"]"
      else
        echo "depends = [\"deps\"]"
      fi

    } > "$project_root/mise.toml"

  elif [[ "$project_type" == "go" ]]; then
    local go_default
    go_default=$(grep "^go " "$tool_versions" 2>/dev/null | awk '{print $2}') || true
    [[ -z "$go_default" ]] && go_default=$(grep "^go " "$project_root/go.mod" 2>/dev/null | awk '{print $2}') || true
    [[ -z "$go_default" ]] && go_default=$(mise ls go 2>/dev/null | awk '{print $2}' | tail -1) || true

    local go_version binary_name
    go_version=$(_prompt "Go version" "$go_default")
    binary_name=$(_prompt "Binary name" "$project_name")

    log "Writing mise.toml..."
    {
      echo "[tools]"
      echo "go = \"$go_version\""
      echo ""
      echo "[tasks.up]"
      echo "description = \"Build and run\""
      echo "run = \"go build -o $binary_name . && ./$binary_name\""
      echo "raw = true"
    } > "$project_root/mise.toml"

  elif [[ "$project_type" == "node" ]]; then
    local pm_default="bun"
    [[ -f "$project_root/package-lock.json" ]] && pm_default="npm"
    [[ -f "$project_root/bun.lock" ]] || [[ -f "$project_root/bun.lockb" ]] && pm_default="bun"

    local bun_default
    bun_default=$(grep "^bun " "$tool_versions" 2>/dev/null | awk '{print $2}') || true
    [[ -z "$bun_default" ]] && bun_default=$(mise ls bun 2>/dev/null | awk '{print $2}' | tail -1) || true

    local port_default="3000"
    port_default=$(grep -E '"dev"' "$project_root/package.json" 2>/dev/null | grep -oE "port [0-9]+" | awk '{print $2}' | head -1) || true
    port_default="${port_default:-3000}"

    local bun_version port
    bun_version=$(_prompt "Bun version" "$bun_default")
    port=$(_prompt "PORT" "$port_default")

    log "Writing mise.toml..."
    {
      echo "[tools]"
      echo "bun = \"$bun_version\""
      echo ""
      echo "[env]"
      echo "PORT = \"$port\""
      echo ""
      echo "[tasks.deps]"
      echo "description = \"Install dependencies\""
      echo "run = \"bun install\""
      echo ""
      echo "[tasks.up]"
      echo "description = \"Start dev server\""
      echo "depends = [\"deps\"]"
      echo "run = \"bun dev\""
      echo "raw = true"
      echo ""
      echo "[tasks.setup]"
      echo "description = \"Install deps\""
      echo "depends = [\"deps\"]"
    } > "$project_root/mise.toml"
  fi

  # Trust the new mise.toml
  mise trust "$project_root" 2>/dev/null || true

  # Add .worktrees/ to .gitignore
  if [[ -f "$project_root/.gitignore" ]] && ! grep -q '\.worktrees' "$project_root/.gitignore"; then
    echo '.worktrees/' >> "$project_root/.gitignore"
    info "Added .worktrees/ to .gitignore"
  fi

  # Offer to remove .tool-versions
  if [[ -f "$tool_versions" ]]; then
    local rm_answer
    rm_answer=$(_prompt "Remove .tool-versions? (mise.toml replaces it) (y/n)" "y")
    if [[ "$rm_answer" == "y" ]]; then
      rm "$tool_versions"
      info "Removed .tool-versions"
    fi
  fi

  echo ""
  echo -e "${BOLD}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
  echo -e "${BOLD}Done! mise.toml created for: $project_name${NC}"
  echo -e "${BOLD}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
  echo ""
  echo "Next steps:"
  echo "  dev up     # start the server"
  echo "  dev info   # show project config"
  echo ""
}

cmd_wt() {
  if [[ $# -eq 0 ]]; then
    err "Usage: dev wt <create|remove|list> [args]"
    exit 1
  fi

  case "$1" in
    create) shift; wt_create "$@" ;;
    remove) shift; wt_remove "$@" ;;
    list)   shift; wt_list "$@" ;;
    *)      err "Unknown worktree command: $1"; exit 1 ;;
  esac
}

main() {
  if [[ $# -eq 0 ]]; then
    usage
    exit 0
  fi

  case "$1" in
    up|down|setup)
      # Apply worktree context if needed, then delegate to mise
      apply_worktree_context
      # Load mise env into current process so worktree overrides (e.g. DB_NAME
      # from mise.local.toml) take precedence over any direnv-set values
      load_mise_env
      exec mise run "$@"
      ;;
    init)     cmd_init ;;
    info)     cmd_info ;;
    wt)       shift; cmd_wt "$@" ;;
    -h|--help)  usage ;;
    -v|--version) echo "dev $VERSION" ;;
    *)        err "Unknown command: $1"; usage; exit 1 ;;
  esac
}

main "$@"
